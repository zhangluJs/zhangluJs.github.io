# HTTP缓存

浏览器缓存就是把一个已经请求过的Web资源（如html页面，图片，js，数据等）拷贝一份副本储存在浏览器中。缓存会根据进来的请求保存输出内容的副本。当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。

**为什么使用缓存**
1. 减少网络带宽消耗
    - 无论对与网站运营者或者用户，带宽都代表着金钱，过多的带宽消耗，只会便宜了网络运营商。当web缓存副本被使用时，只会产生很小的网络流量，可以有效降低网络成本。
2. 降低服务器压力
    - 用户可以重复的使用本地的缓存，减少对服务器的请求，间接减少了对服务器的压力。
3. 减少网络延迟，提高加载速度
    - 缓存的使用能够明显加快网页的打开速度，达到更好的体验。

**http缓存**

http缓存分为两种，一种是协商缓存、另一种是强制缓存。

1. 强制缓存：浏览器发送网络请求，通过响应头的expires或cache-control字段来判断是否命中了强制缓存。如果命中，则本次请求就不会与服务器进行通信。`注意：如果同时存在expires与cache-control，cache-control优先级更高一些`。

    expires：会设置一个过期时间，如果超过了该时间就会重亲请求服务器，否则使用缓存资源。expires是HTTP1.0中的标准，现在更倾向与使用HTTP1.1中的cache-control。

    cache-control：通过不同字段来响应不同的结果

        pubilc（可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。）
        private（只用被用户终端的浏览器缓存，不能被CDN等中继缓存服务器对其缓存）
        no-store（禁止缓存，每次都会向服务器重新发起请求，每次都会下载完整的资源）
        max-age（计算出一个资源过期时间，再拿这个过期时间与当前时间比较，如果在过期时间之前则使用缓存，否则重新请求）
        no-cache（不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果响应存在ETag，那么请求的时候就会与服务端进行验证，如果资源未被修改，则可以避免重新下载）。 

2. 协商缓存：协商缓存都是由服务器来确定缓存是否可用，所以客户端需要与服务器端通过某种标识来进行通信，从而让服务器判断请求是否可以缓存访问。主要涉及到下面两组头部字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（last-Modified或者ETag），则后续请求则也会带上相应的字段（if-Modified-since或者if-None-Match），若响应头没有last-Modified或者ETag，则请求头也不会有相应的字段。

    Last-Modified/If-Modified-Since：二者的值都是GMT格式的时间字符串。在浏览器第一次发送请求时，response的头部会带上last-Modified，也就是资源最后一次修改时间。下次一次浏览器发送请求时，request头部会将这个时间上，服务器端进行判断来决定是否返回新的资源，如果该时间没有过期则返回304 Not Modified，浏览器收到304的响应后，就会从缓存中读取。如果过期了，服务器端返回新的资源，并且返回一个新的last-Modified时间。

    Etag/If-None-Match：这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。 

    `Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。`